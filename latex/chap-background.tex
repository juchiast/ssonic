\chapter{Background}
\label{chap-background}

\section{Introduction to Abstract Algebra}

\subsection{Basic structures}

\begin{definition}[Monoid]
A \textup{monoid} is a tuple $(G, \cdot)$, where $G$ is a set and $(\cdot) : G \times G \to G$ is a binary operation on $G$, that satisfies these axioms:
\begin{itemize}
    \item \textup{Closure:} For all $a, b \in G$, $a \cdot b \in G$.
    \item \textup{Associativity:} For all $a, b, c \in G$, $a \cdot (b \cdot c) = (a \cdot b) \cdot c$
    \item \textup{Identity element:} There exists an \textup{identity element} $e \in G$ such that $\forall a \in G, a \cdot e = e \cdot a = a$. Such element can be proved to be unique.
\end{itemize}
\end{definition}

\begin{definition}[Group]
A \textup{group} is a \textup{monoid} $(G, \cdot)$ such that every element has an \textup{inverse element} defined by:
\begin{itemize}
    \item \textup{Inverse element:} For all $a \in G$, there exists an \textup{inverse element} of $a$, denoted $a^{-1}$, such that $a \cdot a^{-1} = a^{-1} \cdot a = e$, where $e$ is the identity element.
\end{itemize}
\end{definition}

\begin{definition}[Abelian group]
An \textup{Abelian group}, also called a \textup{commutative group}, is a group $(G, \cdot)$ that satisfies the commutative axiom:
\begin{itemize}
    \item \textup{Commutative:} For all $a, b \in G$, $a \cdot b = b \cdot a$.
\end{itemize}
\end{definition}

\begin{definition}[Ring]
A \textup{ring} is a set $R$ equipped with two binary operation $(+)$ and $(\cdot)$ on $R$, called \textup{addition} and \textup{multiplication}, such that:
\begin{itemize}
    \item $R$ is an \textup{Abelian group} under addition. The identity element of $(R, +)$ is denoted $0$.
    \item $R$ is a \textup{monoid} under multiplication. The identity element of $(R, \cdot)$ is denoted $1$.
    \item Multiplication is \textup{distributive} with respect to addition:
    \begin{itemize}
        \item For all a, b, c in $R$, $a + (b \cdot c) = a \cdot b + a \cdot c$
        \item For all a, b, c in $R$, $(b \cdot c) + a = b \cdot a + c \cdot a$
    \end{itemize}
\end{itemize}
\end{definition}

\begin{definition}[Field]
A \textup{field} is a set $F$ equipped with two binary operation $(+)$ and $(\cdot)$ on $F$, called \textup{addition} and \textup{multiplication}, such that:
\begin{itemize}
    \item $F$ is an \textup{Abelian group} under addition. The identity element of $(F, +)$ is denoted $0$.
    \item $F \setminus \{0\}$ is an \textup{Abelian group} under multiplication. The identity element of $(f \setminus \{0\}, \cdot)$ is denoted $1$.
    \item Multiplication is \textup{distributive} with respect to addition:
    \begin{itemize}
        \item For all $a, b, c \in \F$, $a + (b \cdot c) = a \cdot b + a \cdot c$
    \end{itemize}
\end{itemize}
\end{definition}

\subsection{Subgroups, cyclic groups, generators, and orders}

Let $(G, \cdot)$ be a group and $g \in G$ be an element of the group, denote by $g^k$ the result of applying $(\cdot)$ to $g$ repeatedly, e.g. $g^2 = g \cdot g$, $g^3 = g \cdot g \cdot g$, etc.

\begin{definition}[Generating set of a group]
Let $(G, \cdot)$ be a group and let $S \subset G$, $S$ is called \textup{generating set} of $G$ if for all $x \in G$, exists $g \in S$ such that $x = g^k$ for some $k \in \N$. We call elements of $S$ \textup{generators} of $G$.

We denote $\langle S \rangle$ the group generated by $S$. We denote $\langle g \rangle$ the group generated by a single element $g \in G$.
\end{definition}

\begin{definition}[Cyclic group]
A group $(G, \cdot)$ is \textup{cyclic} if it is generated by a single element $g \in G$, i.e. $G = \langle g \rangle$.
\end{definition}

\begin{definition}[Orders]
The \textup{order} of a group $(G, \cdot)$ is the number of element in the set $G$, denoted $|G|$.

The order of an element $g \in G$ is the order of $\langle g \rangle$, denoted $|\langle g \rangle|$.
\end{definition}

\begin{definition}[Subgroup]
A group $(H, \cdot)$ is a \textup{subgroup} of $(G, \cdot)$ if $H \subset G$ and $(G, \cdot)$ is a group. We write $H \le G$ if $H$ is a subgroup of $G$.
\end{definition}

\begin{theorem}[Lagrange's theorem]
Let $G$ be a group and $H$ be a subgroup of $G$, we have that $|G|$ is divisible by $|H|$.
\end{theorem}

\subsection{Finite fields}

\begin{definition}[Finite field]
$(F, +, \cdot)$ is a \textup{finite field} if $(F, +, \cdot)$ is a \textup{field} and the set $F$ is a finite set.
\end{definition}

\textbf{Existence.} Finite fields with the same number of elements are isomorphic to each other, therefore we use the number of elements to refer to the field. Denote $\GF(q)$ to be the finite field with $q$ elements, $\GF(q)$ exists if and only if $q$ is a power of a prime $p$, $q = p^k$. If $q$ is a prime number then the field is called a prime field.

In this thesis, we will only be using $\Z_p$, the field of integers modulo a prime $p$.

\section{Computational Models}

We provide some backgrounds on computational complexity theory.

\begin{definition}[NP relation]
A Boolean relation $\mathcal{R}$ is in NP if there exists a deterministic polynomial-time algorithm $\mathcal{P}$ such that $\pair{x}{w} \in \mathcal{R} \iff \mathcal{P}(x, w) = 1$. We write $\mathcal{R} = \{ \pair{x}{w} : \mathcal{P}(x, w) = 1 \}$. $x$ is called an \textup{instance} and $w$ is a \textup{witness} of $x$.

We denote by $\mathcal{L(R)}$ the corresponding language of $\mathcal{R}$, $\mathcal{L} = \{ x : \exists w, \pair{x}{w} \in \mathcal{R} \}$. 
\end{definition}

\begin{definition}[Probabilistic machine]
A probabilistic machine $\mP$ is a machine that has access to a random source. On input $x$, $\mP(x)$ is a random distribution of possible outputs of $\mP$.
\end{definition}

\textbf{Remark.} Probabilistic machines can also be constructed as a deterministic machine with two inputs, the main input $x$ and the random coins $r$.

We heavily use \textit{probabilistic polynomial-time} (PPT) machines to represent cryptographic computations and adversaries.

\textbf{Oracle.} An \textit{oracle} is a black-box that can answer to queries. For example, in the Random Oracle model, a \textit{random oracle} responses to each query $x$ with a truly random response; in Polynomial IOP model, an oracle $\pi$ responses to query $z$ with an evaluation of some polynomial $f(X)$ at $z$.

\textbf{Oracle machine.} An \textit{oracle machine} is a machine with accesses to some \textit{oracle}.

\section{Probability Theory}

We recall relevant results in probability theory. We will only be using \textit{discrete} probability distributions in this thesis.

\textbf{Notations:}
\begin{itemize}
    \item $\pr{\omega}$: The probability that an event $\omega$ happens.
    \item $[a, b]$: The uniform distribution over the set $\{ x : x \in \Z, a \le x \le b\}$.
    \item $x \rand U$: sample $x$ from a distribution $U$.
\end{itemize}

\textbf{Negligible probability.} We write $\pr{\omega} \le \negl$ to say that the probability that event $\omega$ happens is negligible, where $\negl$ is a \textit{negligible function} in $\lambda$.

\begin{definition}[Negligible function]
A function $f: \N \to \R$ is \textup{negligible} if for every polynomial $p(\cdot)$ there exists $N$ such that for all $n > N$,
$$f(n) < \frac{1}{p(n)}$$
\end{definition}

\textbf{Indistinguishability of probability distributions.} Computational and statistical indistinguishability are patterns that are used in definitions of hiding commitments and zero-knowledge arguments. Two distributions $U$ and $V$ are \textit{computational indistinguishable} if no efficient machine can distinguish between a sample of $U$ and $V$, they are \textit{statistically indistinguishable} if they are \textit{statistically close}.

\begin{definition}[Computational indistinguishability]
Two probability distributions $U$ and $V$ are \textup{computational indistinguishable} if for every PPT algorithm $\mD$, we have
$$|\pr{\mD(U) = 1} - \pr{\mD(V) = 1}| \le \negl$$
\end{definition}

\begin{definition}[Statistically indistinguishability]
Two probability distributions $U$ and $V$ are \textup{statistically indistinguishable} if the \textup{total variation distance} between them is negligible.
\end{definition}

\begin{definition}[Total variation distance]
\textup{Total variation distance} between two probability distributions $U$ and $V$ over the sample space $\Omega$ is defined by
$$\delta(U, V) = \frac{1}{2} \sum_{x \in \Omega} |\pr{U = x} - \pr{V = x}|$$
\end{definition}

\begin{lemma}
\textup{Statistically indistinguishability} implies \textup{computational indistinguishability} \cite{goldreich2007foundations}.
\end{lemma}

The following distance is being used in zero-knowledge construction of DARK.\\
Let $U = [0, a)$ and $V = [0, b)$ be the uniform distributions over the integer ranges $[0, a)$ and $[0, b)$. We have that
\begin{align*}
\delta(U, V) &= \frac{1}{2} \sum_{x=0}^{a-1} \left\vert\frac{1}{a} - \frac{1}{b}\right\vert + \frac{1}{2}\sum_{x=a}^{b-1} \left\vert0 - \frac{1}{b}\right\vert \\ 
& = \frac{b-a}{b}
\end{align*}

\section{Cryptographic Assumptions}

We relies on various hardness assumptions on group of unknown orders.
The assumptions on this section consider a \textit{group generator} $GGEN$ that, given security parameter $\lambda$, outputs a (random) group of unknown order $\G$.

\begin{assumption}[Adaptive Root assumption]
\label{adaptive-root}
The Adaptive Root assumption holds for $GGen$ if for all PPT adversaries $(\mA_0, \mA_1)$,
\begin{align*}
\pr{\mathsf{u}^l = w \ne 1 : \begin{array}{l}
\G \gets GGen(\lambda) \\
(\mathsf{w}, \mathrm{st}) \gets \mA_0(\G) \\
l \rand \mathrm{Primes}(\lambda) \\
\mathsf{u} \gets \mA_1(l, \mathrm{st})
\end{array}} \le \negl
\end{align*}
\end{assumption}

\begin{assumption}[$r$-Strong RSA assumption]
\label{r-strong-rsa}
The $r$-Strong RSA assumption holds for $GGen$ if for all efficient adversaries $\mA$,
\begin{align*}
\pr{
\begin{array}{l}
\mathsf{u}^l = \mathsf{g} \text{ \textup{and}} \\
l \ne r^k, k \in \N
\end{array}
:
\begin{array}{l}
\G \gets GGen(\lambda) \\
\gG \rand \G \\
(\mathsf{u}, l) \in \G \times \N \gets \mA(\G, \gG)
\end{array}
} \le \negl
\end{align*}
\end{assumption}

\begin{assumption}[Low Order assumption]
\label{low-order}
The Low Order assumption holds for $GGen$ if for all efficient adversaries $\mA$,
\begin{align*}
\pr{
\mathsf{w} \ne 1 \wedge \mathsf{w}^l = 1
:
\begin{array}{l}
\G \gets GGen(\lambda) \\
(\mathsf{w}, l) \gets \mA(\G) \\
\text{\textup{where }} |l| < 2^{\mathrm{poly}(\lambda)} \in \N \\
\text{\textup{and }} \mathsf{w} \in \G
\end{array}
} \le \negl
\end{align*}
\end{assumption}

\begin{assumption}[$r$-Fractional Root assumption]
\label{fractional-root}
The $r$-Fractional Root assumption holds for $GGen$ if for all efficient adversaries $\mA$,
\begin{align*}
\pr{
\begin{array}{l}
\mathsf{u}^\beta = \mathsf{g}^\alpha \text{\textup{ and}} \\
\frac{\beta}{\mathrm{gcd}(\alpha, \beta)} \ne r^k, k \in \N
\end{array}
:
\begin{array}{l}
\G \gets GGen(\lambda) \\
\gG \rand \G \\
(\alpha, \beta, \mathsf{u}) \gets \mA(\G, \gG) \\
\text{\textup{where }} \mathsf{u} \in \G, \\
|\alpha| < 2^{\mathrm{poly}(\lambda)} \in \N \\
|\beta| < 2^{\mathrm{poly}(\lambda)} \in \N
\end{array}
} \le \negl
\end{align*}
\end{assumption}

\begin{claim}
The Adaptive Root assumption implies the Low Order assumption \cite{bunz2020transparent}.
\end{claim}

\begin{claim}
The Adaptive Root assumption and the r-Strong RSA assumption imply the r-Fractional Root assumption \cite{bunz2020transparent}.
\end{claim}

\section{Interactive Arguments}

Informally, an \textit{interactive proof} for an NP relation $\mathcal{R}$ is defined by a pair of PPT interactive machines $(\mP, \mV)$ that satisfies the conditions:
\begin{itemize}
    \item Completeness: For all $x \in \mathcal{L}(\mathcal{R})$, $\mV$ outputs "accept" after interacting with $\mP$.
    \item Soundness: For all $x \not\in \mathcal{L}(\mathcal{R})$, no adversary could convince the verifier that $x \in \mathcal{L}(\mathcal{R})$.
\end{itemize}

\textbf{Proof versus argument.} In the literature, \textit{proof} is used when the protocol is sound for \textit{all} adversaries, 
whereas \textit{argument} is safe for \textit{efficient} adversaries.

\begin{definition}[Interactive Argument]
\label{intarctive-argument}
Let $\mathcal{R}$ be an NP relation and $\mathcal{L}(\mathcal{R})$ be the corresponding language of $\mathcal{R}$.
Let $(\mP, \mV)$ be a pair of PPT interactive machines. Let $\aSetup$ be a PPT algorithm that output public parameter $\pp$ given a security parameter.
Denote by $\langle \mP(\pp, x, w), \mV(\pp, x) \rangle$ the output of $\mV$ after interacting with $\mP$, the tuple $(\aSetup, \mP, \mV)$ is an \textup{interactive argument} for a relation $\mathcal{R}$ if the two conditions hold:
\begin{itemize}
    \item \textup{Perfect Completeness:} $\forall (x, w) \in \mathcal{R}$, $$\pr{\langle \mP(\pp, x, w), \mV(\pp, x) \rangle = 1 : \pp \gets \aSetup(\lambda)} = 1$$
    \item \textup{Computational Soundness:} For all PPT adversaries $(\mA_0, \mA_1)$,
    \begin{align*}
    \pr{
    \langle \mA_1(\mathrm{st}, x), \mV(\pp, x) \rangle = 1 \wedge x \not\in \mathcal{L}(\mathcal{R}) : \begin{array}{l}
         \pp \gets \aSetup(\lambda) \\
         (\mathrm{st}, x) \gets \mA_0(\pp)
    \end{array}
    } \le \negl    
    \end{align*}
\end{itemize}
\end{definition}

\begin{definition}[Public-coin argument] An interactive argument $(\aSetup, \mP, \mV)$ is public-coin if $\mV$'s messages are chosen from uniform random distributions, independent of $\mP$'s messages and public parameters.
\end{definition}

\textbf{Honest-verifier Zero-knowledge (HVZK).} The first zero-knowledge proof constructions of Goldwasser et al. \cite{goldreich1986prove} consider zero-knowledge property for \textit{malicious} verifiers, which means the protocol is zero-knowledge even when the verifier does not follow the protocol. However, SNARKs are non-interactive, verifiers do not have interactions with the prover, therefore we only need an \textit{honest-verifier} zero-knowledge interactive argument, then the Fiat-Shamir heuristic is used to get a non-interactive protocol. In both cases, zero-knowledge is defined using the simulator paradigm: if there exists a PPT algorithm which outputs a transcript that is indistinguishable from a real transcript, then the verifier gains no knowledge from the interaction. Malicious-verifier zero-knowledge considers the view of all verifiers, whereas honest-verifier zero-knowledge only considers the view of honest verifier. We use Statistical HVZK definition in \cite{bunz2020transparent}.

\begin{definition}[HVZK for interactive arguments \cite{bunz2020transparent}]
Let $(\aSetup, \mP, \mV)$ be defined as in definition \ref{intarctive-argument}.
Let $\aView(\mP(\pp, x, w), \mV(\pp, x))$ denote the distribution of the transcript of $\mP$ and $\mV$'s interaction. The interactive protocol has $\delta$-statistical honest-verifier zero-knowledge if there exists a PPT algorithm $\mS$ such that the statistical distance between $\mS(\pp, x)$ and $\aView(\mP(\pp, x, w), \mV(\pp, x))$ is less than $\delta$.
\end{definition}

\section{Arguments of Knowledge}

\textit{Proof of knowledge} not only attests that $x \in \mathcal{L(R)}$ for some statement $x$, it also attests that $\mP$ knows $w$ such that $(x, w) \in \mathcal{R}$.

Originally, \textit{proof of knowledge} is formalized as the existence of a \textit{knowledge extractor} that, when given oracle accesses to a prover, can output a witness for the instance being proved \cite{bellare1992defining}, this property is often referred as \textit{knowledge soundness} or \textit{validity}.

Later, Lindell extended this definition to \textit{witness-extended emulation} \cite{lindell2003parallel}, which basically requires that, for all prover $\mP^*$ there exists an emulator which outputs:
\begin{itemize}
    \item A transcript $\mathsf{tr}$ of the interaction between $\mP^*$ and $\mV$.
    \item A witness $w$ such that if $tr$ is accepting then $w$ is a \textit{valid} witness for the instance being proved.
\end{itemize}

Witness-extended emulation makes it easier to use proof of knowledge as a sub-protocol in other protocols \cite{lindell2003parallel}, this is the intention behind the definition.

\begin{definition}[Witness-extended emulation \cite{lindell2003parallel}]
Let $(\aSetup, \mP, \mV)$ be a public-coin interactive argument for an NP relation $\mathcal{R}$, let $\mP^*$ be an arbitrary prover algorithm, let $\Record(\mP^*, \pp, x, \mathsf{st})$ be the transcript of $\mV$ when interacting with $\mP^*$ on common input $(\pp, x)$ and initial prover state $\mathsf{st}$. Let $\mE^{\Record(\mP^*, \pp, x, \mathsf{st})}$ be a machine with oracle access to $\Record(\mP^*, \pp, x, \mathsf{st})$ that can rewind and run again at any step on fresh verifier randomness. $(\aSetup, \mP, \mV)$ has \textup{witness-extended emulation} if for every deterministic polynomial time $\mP^*$ there exists an expected polynomial time emulator $\mE$ such that for all PPT adversaries $(\mA_0, \mA_1)$:
\begin{itemize}
    \item The transcript that $\mE$ outputs is indistinguishable from a real transcript between $\mP^*$ and $\mV$,
    \begin{align*}
    & \pr{\mA_1(\mathsf{tr}) = 1 : \begin{array}{l}
    \pp \gets \aSetup(\lambda) \\
    (x, \mathsf{st}) \gets \mA_0(\pp) \\
    \mathsf{tr} \gets \Record(\mP^*, \pp, x, \mathsf{st})
    \end{array}} \\
    \approx\ 
    & \pr{\mA_1(\mathsf{tr}) = 1 :
    \begin{array}{l}
    \pp \gets \aSetup(\lambda) \\
    (x, \mathsf{st}) \gets \mA_0(\pp) \\
    (\mathsf{tr}, w) \gets \mE^{\Record(\mP^*, \pp, x, \mathsf{st})}(\pp, x)
    \end{array}
    }
    \end{align*}
    \item If $\mE$ outputs an accepting transcript then $w$ is a valid witness,
    \begin{align*}
    \pr{\mathsf{tr} \text{ \textup{accepting}} \wedge (x, w) \not\in \mathcal{R} :
    \begin{array}{l}
    \pp \gets \aSetup(\lambda) \\
    (x, \mathsf{st}) \gets \mA(\pp) \\
    (\mathsf{tr}, w) \gets \mE^{\Record(\mP^*, \pp, x, \mathsf{st})}(\pp, x)
    \end{array}
    } \le \negl
    \end{align*}
\end{itemize}
\end{definition}

The conditions $\mA_1(\mathsf{tr}) = 1$ mean the transcript output by $\mE$ is indistinguishable from a real transcript of $\mP^*$ and $\mV$. $\mA_1$ is treated as a distinguisher for the transcripts.

\textbf{Witness-extended emulation implies soundness.} The soundness condition states that, if $x \not\in \mathcal{L(R)}$ then no prover could convince $\mV$ (except with negligible probability). Suppose $(\aSetup, \mP, \mV)$ has witness-extended emulation, for all $\mP^*$, for all $x \not\in \mathcal{L(R)}$, the probability that $\mE$ outputs a valid witness $w$ is 0 (because there is none), therefore $\mathsf{tr}$ outputted by $\mE$ is not accepting (except with negligible probability). Because $\mE$'s output and $\Record(\mP^*, \pp, x, \mathsf{st})$ are indistinguishable, $\mV$ rejects when interacting with $\mP^*$ (except with negligible probability).

\textbf{General Forking lemma.} Bootle et. al. \cite{bootle2016efficient} introduced a tool to prove \textit{witness-extended emulation} of protocols, which they called the General Forking lemma. In summary, the lemma states that if we can extract a valid witness from a tree of accepting transcripts, then the protocol has witness-extended emulation.

\begin{definition}[General Forking lemma \cite{bunz2020transparent, bootle2016efficient}]
\label{general-forking}
Let $(\aSetup, \mP, \mV)$ be a $r$-round public-coin interactive argument for an NP relation $\mathcal{R}$. Let $\mP^*$ be an arbitrary prover algorithm, let $\Record(\mP^*, \pp, x, \mathsf{st})$ be the transcript of $\mV$ when interacting with $\mP^*$ on common input $(\pp, x)$ and initial prover state $\mathsf{st}$. Let $\mathcal{T}$ be a tree-finder algorithm that, when given access to $\Record(\mP^*, \pp, x, \mathsf{st})$ with rewinding capability, outputs an $(n_1,\dots,n_r)$-tree of accepting transcript with overwhelming probability. Let $\mathcal{X}$ be a deterministic polynomial-time algorithm that, with accesses to $\mathcal{T}$'s output, outputs a witness for the statement being proved with overwhelming probability over the randomness of $\mathcal{T}$. If such $\mathcal{T}$ and $\mathcal{X}$ exist then $(\aSetup, \mP, \mV)$ has witness-extended emulation.

An $(n_1,\dots,n_r)$-tree of accepting transcript for a $r$-round public-coin argument is defined as follow. The tree has depth $r$, the root of the tree is labeled with the statement $x$, an edge is labeled with a message from prover to verifier, each node at depth $i < r$ has $r_i$ children and  each child is labelled with a unique challenge for the $i$-th round.
\end{definition}

\section{Commitment Scheme}

Commitment scheme is a useful cryptographic primitive, it allows a party to commit to a value $x$ via a commitment $c$, and later reveal the value $x$. Two mains properties of commitment schemes are \textit{binding} and \textit{hiding}, which we defined below.

\begin{definition}[Commitment scheme \cite{bunz2020transparent}]
\label{commitment-scheme}
A commitment scheme is a tuple of PPT algorithms $\Gamma = (\mathrm{Setup}, \mathrm{Commit}, \mathrm{Open})$ that satisfies the \textup{binding} property, where:
\begin{itemize}
    \item $\mathrm{Setup}(1^{\lambda}) \to \mathrm{pp}$: produce public parameters.
    \item $\mathrm{Commit}(\mathrm{pp}; x) \to (\mathrm{C}; r)$: take a value $x$ and return public commitment $\mathrm{C}$ of $x$ and private opening hint $r$.
    \item $\mathrm{Open}(\mathrm{pp}, x, \mathrm{C}, r) \to b \in \{0, 1\}$: verify that $\mathrm{C}$ is the commitment of $x$, output $1$ if it is and $0$ if it is not.
\end{itemize}

$\Gamma$ is \textbf{binding} if for all PPT adversaries $\mathcal{A}$
\begin{align*}
\pr{x_0 \ne x_1 \wedge b_0 = b_1 = 1 :
\begin{array}{l}
     \mathrm{pp} \gets \mathrm{Setup}(1^\lambda) \\
     (\mathrm{C}, x_0, x_1, r_0, r_1) \gets \mathcal{A}(\mathrm{pp}) \\
     b_0 \gets \mathrm{Open}(\mathrm{pp}, x_0, \mathrm{C}, r_0) \\
     b_1 \gets \mathrm{Open}(\mathrm{pp}, x_1, \mathrm{C}, r_1)
\end{array}
} \le \mathrm{negl}(\lambda)
\end{align*}
\end{definition}

An additional property for a commitment scheme is \textit{hiding}, which says that it is infeasible to distinguish between commitments of two values.

\begin{definition}[Hiding commitment \cite{bunz2020transparent}]
\label{hiding-commitment}
$\Gamma = (\mathrm{Setup}, \mathrm{Commit}, \mathrm{Open})$ is \textup{hiding} if for all PPT adversaries $(\mathcal{A}_0, \mathcal{A}_1)$ we have

\begin{align*}
\left\vert
1 - 2 \cdot \pr{ b = \hat{b} :
\begin{array}{l}
    \mathrm{pp} \gets \mathrm{Setup}(1^\lambda) \\
    (x_0, x_1, \mathrm{st}) \gets \mathcal{A}_0(\lambda) \\
    b \rand \{0, 1\} \\
    \mathrm{C} \gets \mathrm{Commit}(\mathrm{pp}; x_b) \\
    \hat{b} \gets \mathcal{A}_1(\mathrm{st}, \mathrm{C})
\end{array}
}
\right\vert \le \mathrm{negl}(\lambda)
\end{align*}
\end{definition}

Hiding commitment is an analog of submitting a value in a locked box. For example, we could use a hiding commitment to implement \textit{blind auction}, where participants submit a sealed price that will be opened at the end, \textit{binding} makes sure participants cannot change their submitted value, and \textit{hiding} hides the value from other participants.

\textbf{Polynomial Commitment}: A polynomial commitment scheme is a commitment scheme for messages space $R[X]$ of a ring $R$, paired with an \textit{evaluation protocol}, which is an interactive argument for the relation $\REval$. Polynomial commitment scheme enables the committer to prove that the committed polynomial $f(X)$ evaluates to a value $y$ at at point $z$.

\begin{definition}
\label{r-eval}
Let $\Gamma = (\mathrm{Setup}, \mathrm{Commit}, \mathrm{Open})$ be a commitment scheme for message space $R[X]$ of a ring $R$ and let $\mathrm{pp} \gets \mathrm{Setup}(1^{\lambda})$, we define the relation for polynomial evaluation as
\begin{align*}
\REval(\mathrm{pp})
=
\left\{\langle (\mathrm{C}, d, z, y), (f(X), r) \rangle :
\begin{array}{l}
    f(X) \in R[X], z, y \in R \\
    \mathrm{deg}(f(X)) \le d \\
    f(z) = y \\
    \mathrm{Open}(\mathrm{pp}, f(X), \mathrm{C}, r) = 1
\end{array}
\right\}
\end{align*}
\end{definition}

\begin{definition}[Polynomial Commitment scheme]
\label{polynomial-commitment}
The tuple of PPT algorithms $\Gamma = (\mathrm{Setup}, \mathrm{Commit}, \mathrm{Open}, \mathrm{Eval})$ is a Polynomial Commitment scheme if $(\mathrm{Setup}, \mathrm{Commit}, \mathrm{Open})$ is a binding commitment scheme, and $\mathrm{Eval}$ is an interactive argument for the relation $\REval$.
\end{definition}

